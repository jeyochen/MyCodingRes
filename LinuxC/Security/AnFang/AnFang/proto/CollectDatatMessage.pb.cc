// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: CollectDatatMessage.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "CollectDatatMessage.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace COLLECT_DATA {

namespace {

const ::google::protobuf::Descriptor* MSixLineDC_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MSixLineDC_reflection_ = NULL;
const ::google::protobuf::Descriptor* MSixLineStatus_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MSixLineStatus_reflection_ = NULL;
const ::google::protobuf::Descriptor* MTemperHumidityValue_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MTemperHumidityValue_reflection_ = NULL;
const ::google::protobuf::Descriptor* MCpuLoad_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MCpuLoad_reflection_ = NULL;
const ::google::protobuf::Descriptor* MMemInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MMemInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* MDiskInfoItem_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MDiskInfoItem_reflection_ = NULL;
const ::google::protobuf::Descriptor* MDiskInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MDiskInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* MFangquStatusItem_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MFangquStatusItem_reflection_ = NULL;
const ::google::protobuf::Descriptor* MSKHostInfoItem_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MSKHostInfoItem_reflection_ = NULL;
const ::google::protobuf::Descriptor* MSKHostInfos_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MSKHostInfos_reflection_ = NULL;

}  // namespace


void protobuf_AssignDesc_CollectDatatMessage_2eproto() {
  protobuf_AddDesc_CollectDatatMessage_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "CollectDatatMessage.proto");
  GOOGLE_CHECK(file != NULL);
  MSixLineDC_descriptor_ = file->message_type(0);
  static const int MSixLineDC_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MSixLineDC, line_dc_),
  };
  MSixLineDC_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MSixLineDC_descriptor_,
      MSixLineDC::default_instance_,
      MSixLineDC_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MSixLineDC, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MSixLineDC, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MSixLineDC));
  MSixLineStatus_descriptor_ = file->message_type(1);
  static const int MSixLineStatus_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MSixLineStatus, line_status_),
  };
  MSixLineStatus_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MSixLineStatus_descriptor_,
      MSixLineStatus::default_instance_,
      MSixLineStatus_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MSixLineStatus, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MSixLineStatus, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MSixLineStatus));
  MTemperHumidityValue_descriptor_ = file->message_type(2);
  static const int MTemperHumidityValue_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MTemperHumidityValue, temperature_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MTemperHumidityValue, humidity_),
  };
  MTemperHumidityValue_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MTemperHumidityValue_descriptor_,
      MTemperHumidityValue::default_instance_,
      MTemperHumidityValue_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MTemperHumidityValue, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MTemperHumidityValue, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MTemperHumidityValue));
  MCpuLoad_descriptor_ = file->message_type(3);
  static const int MCpuLoad_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MCpuLoad, load_),
  };
  MCpuLoad_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MCpuLoad_descriptor_,
      MCpuLoad::default_instance_,
      MCpuLoad_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MCpuLoad, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MCpuLoad, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MCpuLoad));
  MMemInfo_descriptor_ = file->message_type(4);
  static const int MMemInfo_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MMemInfo, total_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MMemInfo, free_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MMemInfo, usage_),
  };
  MMemInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MMemInfo_descriptor_,
      MMemInfo::default_instance_,
      MMemInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MMemInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MMemInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MMemInfo));
  MDiskInfoItem_descriptor_ = file->message_type(5);
  static const int MDiskInfoItem_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MDiskInfoItem, space_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MDiskInfoItem, used_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MDiskInfoItem, available_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MDiskInfoItem, usage_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MDiskInfoItem, mount_point_),
  };
  MDiskInfoItem_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MDiskInfoItem_descriptor_,
      MDiskInfoItem::default_instance_,
      MDiskInfoItem_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MDiskInfoItem, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MDiskInfoItem, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MDiskInfoItem));
  MDiskInfo_descriptor_ = file->message_type(6);
  static const int MDiskInfo_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MDiskInfo, diskinfo_),
  };
  MDiskInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MDiskInfo_descriptor_,
      MDiskInfo::default_instance_,
      MDiskInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MDiskInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MDiskInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MDiskInfo));
  MFangquStatusItem_descriptor_ = file->message_type(7);
  static const int MFangquStatusItem_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MFangquStatusItem, status_),
  };
  MFangquStatusItem_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MFangquStatusItem_descriptor_,
      MFangquStatusItem::default_instance_,
      MFangquStatusItem_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MFangquStatusItem, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MFangquStatusItem, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MFangquStatusItem));
  MSKHostInfoItem_descriptor_ = file->message_type(8);
  static const int MSKHostInfoItem_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MSKHostInfoItem, ip_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MSKHostInfoItem, host_status_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MSKHostInfoItem, fangqu_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MSKHostInfoItem, fangqu_status_),
  };
  MSKHostInfoItem_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MSKHostInfoItem_descriptor_,
      MSKHostInfoItem::default_instance_,
      MSKHostInfoItem_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MSKHostInfoItem, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MSKHostInfoItem, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MSKHostInfoItem));
  MSKHostInfos_descriptor_ = file->message_type(9);
  static const int MSKHostInfos_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MSKHostInfos, sk_alarm_),
  };
  MSKHostInfos_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MSKHostInfos_descriptor_,
      MSKHostInfos::default_instance_,
      MSKHostInfos_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MSKHostInfos, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MSKHostInfos, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MSKHostInfos));
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_CollectDatatMessage_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MSixLineDC_descriptor_, &MSixLineDC::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MSixLineStatus_descriptor_, &MSixLineStatus::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MTemperHumidityValue_descriptor_, &MTemperHumidityValue::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MCpuLoad_descriptor_, &MCpuLoad::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MMemInfo_descriptor_, &MMemInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MDiskInfoItem_descriptor_, &MDiskInfoItem::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MDiskInfo_descriptor_, &MDiskInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MFangquStatusItem_descriptor_, &MFangquStatusItem::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MSKHostInfoItem_descriptor_, &MSKHostInfoItem::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MSKHostInfos_descriptor_, &MSKHostInfos::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_CollectDatatMessage_2eproto() {
  delete MSixLineDC::default_instance_;
  delete MSixLineDC_reflection_;
  delete MSixLineStatus::default_instance_;
  delete MSixLineStatus_reflection_;
  delete MTemperHumidityValue::default_instance_;
  delete MTemperHumidityValue_reflection_;
  delete MCpuLoad::default_instance_;
  delete MCpuLoad_reflection_;
  delete MMemInfo::default_instance_;
  delete MMemInfo_reflection_;
  delete MDiskInfoItem::default_instance_;
  delete MDiskInfoItem_reflection_;
  delete MDiskInfo::default_instance_;
  delete MDiskInfo_reflection_;
  delete MFangquStatusItem::default_instance_;
  delete MFangquStatusItem_reflection_;
  delete MSKHostInfoItem::default_instance_;
  delete MSKHostInfoItem_reflection_;
  delete MSKHostInfos::default_instance_;
  delete MSKHostInfos_reflection_;
}

void protobuf_AddDesc_CollectDatatMessage_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\031CollectDatatMessage.proto\022\014COLLECT_DAT"
    "A\"\035\n\nMSixLineDC\022\017\n\007line_dc\030\001 \003(\002\"%\n\016MSix"
    "LineStatus\022\023\n\013line_status\030\001 \003(\010\"=\n\024MTemp"
    "erHumidityValue\022\023\n\013temperature\030\001 \001(\002\022\020\n\010"
    "humidity\030\002 \001(\002\"\030\n\010MCpuLoad\022\014\n\004load\030\001 \001(\005"
    "\"6\n\010MMemInfo\022\r\n\005total\030\001 \001(\003\022\014\n\004free\030\002 \001("
    "\003\022\r\n\005usage\030\003 \001(\002\"c\n\rMDiskInfoItem\022\r\n\005spa"
    "ce\030\001 \001(\002\022\014\n\004used\030\002 \001(\002\022\021\n\tavailable\030\003 \001("
    "\002\022\r\n\005usage\030\004 \001(\002\022\023\n\013mount_point\030\005 \001(\t\":\n"
    "\tMDiskInfo\022-\n\010diskinfo\030\001 \003(\0132\033.COLLECT_D"
    "ATA.MDiskInfoItem\"#\n\021MFangquStatusItem\022\016"
    "\n\006status\030\001 \001(\005\"\177\n\017MSKHostInfoItem\022\n\n\002ip\030"
    "\001 \001(\t\022\023\n\013host_status\030\002 \001(\005\022\023\n\013fangqu_typ"
    "e\030\003 \001(\005\0226\n\rfangqu_status\030\004 \003(\0132\037.COLLECT"
    "_DATA.MFangquStatusItem\"\?\n\014MSKHostInfos\022"
    "/\n\010sk_alarm\030\001 \003(\0132\035.COLLECT_DATA.MSKHost"
    "InfoItem", 648);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "CollectDatatMessage.proto", &protobuf_RegisterTypes);
  MSixLineDC::default_instance_ = new MSixLineDC();
  MSixLineStatus::default_instance_ = new MSixLineStatus();
  MTemperHumidityValue::default_instance_ = new MTemperHumidityValue();
  MCpuLoad::default_instance_ = new MCpuLoad();
  MMemInfo::default_instance_ = new MMemInfo();
  MDiskInfoItem::default_instance_ = new MDiskInfoItem();
  MDiskInfo::default_instance_ = new MDiskInfo();
  MFangquStatusItem::default_instance_ = new MFangquStatusItem();
  MSKHostInfoItem::default_instance_ = new MSKHostInfoItem();
  MSKHostInfos::default_instance_ = new MSKHostInfos();
  MSixLineDC::default_instance_->InitAsDefaultInstance();
  MSixLineStatus::default_instance_->InitAsDefaultInstance();
  MTemperHumidityValue::default_instance_->InitAsDefaultInstance();
  MCpuLoad::default_instance_->InitAsDefaultInstance();
  MMemInfo::default_instance_->InitAsDefaultInstance();
  MDiskInfoItem::default_instance_->InitAsDefaultInstance();
  MDiskInfo::default_instance_->InitAsDefaultInstance();
  MFangquStatusItem::default_instance_->InitAsDefaultInstance();
  MSKHostInfoItem::default_instance_->InitAsDefaultInstance();
  MSKHostInfos::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_CollectDatatMessage_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_CollectDatatMessage_2eproto {
  StaticDescriptorInitializer_CollectDatatMessage_2eproto() {
    protobuf_AddDesc_CollectDatatMessage_2eproto();
  }
} static_descriptor_initializer_CollectDatatMessage_2eproto_;

// ===================================================================

#ifndef _MSC_VER
const int MSixLineDC::kLineDcFieldNumber;
#endif  // !_MSC_VER

MSixLineDC::MSixLineDC()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void MSixLineDC::InitAsDefaultInstance() {
}

MSixLineDC::MSixLineDC(const MSixLineDC& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void MSixLineDC::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MSixLineDC::~MSixLineDC() {
  SharedDtor();
}

void MSixLineDC::SharedDtor() {
  if (this != default_instance_) {
  }
}

void MSixLineDC::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MSixLineDC::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MSixLineDC_descriptor_;
}

const MSixLineDC& MSixLineDC::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CollectDatatMessage_2eproto();
  return *default_instance_;
}

MSixLineDC* MSixLineDC::default_instance_ = NULL;

MSixLineDC* MSixLineDC::New() const {
  return new MSixLineDC;
}

void MSixLineDC::Clear() {
  line_dc_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MSixLineDC::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated float line_dc = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_line_dc:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 1, 13, input, this->mutable_line_dc())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_line_dc())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(13)) goto parse_line_dc;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MSixLineDC::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated float line_dc = 1;
  for (int i = 0; i < this->line_dc_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(
      1, this->line_dc(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* MSixLineDC::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated float line_dc = 1;
  for (int i = 0; i < this->line_dc_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteFloatToArray(1, this->line_dc(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int MSixLineDC::ByteSize() const {
  int total_size = 0;

  // repeated float line_dc = 1;
  {
    int data_size = 0;
    data_size = 4 * this->line_dc_size();
    total_size += 1 * this->line_dc_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MSixLineDC::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MSixLineDC* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MSixLineDC*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MSixLineDC::MergeFrom(const MSixLineDC& from) {
  GOOGLE_CHECK_NE(&from, this);
  line_dc_.MergeFrom(from.line_dc_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MSixLineDC::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MSixLineDC::CopyFrom(const MSixLineDC& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MSixLineDC::IsInitialized() const {

  return true;
}

void MSixLineDC::Swap(MSixLineDC* other) {
  if (other != this) {
    line_dc_.Swap(&other->line_dc_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MSixLineDC::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MSixLineDC_descriptor_;
  metadata.reflection = MSixLineDC_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MSixLineStatus::kLineStatusFieldNumber;
#endif  // !_MSC_VER

MSixLineStatus::MSixLineStatus()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void MSixLineStatus::InitAsDefaultInstance() {
}

MSixLineStatus::MSixLineStatus(const MSixLineStatus& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void MSixLineStatus::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MSixLineStatus::~MSixLineStatus() {
  SharedDtor();
}

void MSixLineStatus::SharedDtor() {
  if (this != default_instance_) {
  }
}

void MSixLineStatus::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MSixLineStatus::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MSixLineStatus_descriptor_;
}

const MSixLineStatus& MSixLineStatus::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CollectDatatMessage_2eproto();
  return *default_instance_;
}

MSixLineStatus* MSixLineStatus::default_instance_ = NULL;

MSixLineStatus* MSixLineStatus::New() const {
  return new MSixLineStatus;
}

void MSixLineStatus::Clear() {
  line_status_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MSixLineStatus::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated bool line_status = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_line_status:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 1, 8, input, this->mutable_line_status())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, this->mutable_line_status())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(8)) goto parse_line_status;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MSixLineStatus::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated bool line_status = 1;
  for (int i = 0; i < this->line_status_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(
      1, this->line_status(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* MSixLineStatus::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated bool line_status = 1;
  for (int i = 0; i < this->line_status_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteBoolToArray(1, this->line_status(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int MSixLineStatus::ByteSize() const {
  int total_size = 0;

  // repeated bool line_status = 1;
  {
    int data_size = 0;
    data_size = 1 * this->line_status_size();
    total_size += 1 * this->line_status_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MSixLineStatus::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MSixLineStatus* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MSixLineStatus*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MSixLineStatus::MergeFrom(const MSixLineStatus& from) {
  GOOGLE_CHECK_NE(&from, this);
  line_status_.MergeFrom(from.line_status_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MSixLineStatus::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MSixLineStatus::CopyFrom(const MSixLineStatus& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MSixLineStatus::IsInitialized() const {

  return true;
}

void MSixLineStatus::Swap(MSixLineStatus* other) {
  if (other != this) {
    line_status_.Swap(&other->line_status_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MSixLineStatus::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MSixLineStatus_descriptor_;
  metadata.reflection = MSixLineStatus_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MTemperHumidityValue::kTemperatureFieldNumber;
const int MTemperHumidityValue::kHumidityFieldNumber;
#endif  // !_MSC_VER

MTemperHumidityValue::MTemperHumidityValue()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void MTemperHumidityValue::InitAsDefaultInstance() {
}

MTemperHumidityValue::MTemperHumidityValue(const MTemperHumidityValue& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void MTemperHumidityValue::SharedCtor() {
  _cached_size_ = 0;
  temperature_ = 0;
  humidity_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MTemperHumidityValue::~MTemperHumidityValue() {
  SharedDtor();
}

void MTemperHumidityValue::SharedDtor() {
  if (this != default_instance_) {
  }
}

void MTemperHumidityValue::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MTemperHumidityValue::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MTemperHumidityValue_descriptor_;
}

const MTemperHumidityValue& MTemperHumidityValue::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CollectDatatMessage_2eproto();
  return *default_instance_;
}

MTemperHumidityValue* MTemperHumidityValue::default_instance_ = NULL;

MTemperHumidityValue* MTemperHumidityValue::New() const {
  return new MTemperHumidityValue;
}

void MTemperHumidityValue::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    temperature_ = 0;
    humidity_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MTemperHumidityValue::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional float temperature = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &temperature_)));
          set_has_temperature();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_humidity;
        break;
      }

      // optional float humidity = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_humidity:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &humidity_)));
          set_has_humidity();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MTemperHumidityValue::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional float temperature = 1;
  if (has_temperature()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->temperature(), output);
  }

  // optional float humidity = 2;
  if (has_humidity()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->humidity(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* MTemperHumidityValue::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional float temperature = 1;
  if (has_temperature()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->temperature(), target);
  }

  // optional float humidity = 2;
  if (has_humidity()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->humidity(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int MTemperHumidityValue::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional float temperature = 1;
    if (has_temperature()) {
      total_size += 1 + 4;
    }

    // optional float humidity = 2;
    if (has_humidity()) {
      total_size += 1 + 4;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MTemperHumidityValue::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MTemperHumidityValue* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MTemperHumidityValue*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MTemperHumidityValue::MergeFrom(const MTemperHumidityValue& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_temperature()) {
      set_temperature(from.temperature());
    }
    if (from.has_humidity()) {
      set_humidity(from.humidity());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MTemperHumidityValue::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MTemperHumidityValue::CopyFrom(const MTemperHumidityValue& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MTemperHumidityValue::IsInitialized() const {

  return true;
}

void MTemperHumidityValue::Swap(MTemperHumidityValue* other) {
  if (other != this) {
    std::swap(temperature_, other->temperature_);
    std::swap(humidity_, other->humidity_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MTemperHumidityValue::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MTemperHumidityValue_descriptor_;
  metadata.reflection = MTemperHumidityValue_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MCpuLoad::kLoadFieldNumber;
#endif  // !_MSC_VER

MCpuLoad::MCpuLoad()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void MCpuLoad::InitAsDefaultInstance() {
}

MCpuLoad::MCpuLoad(const MCpuLoad& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void MCpuLoad::SharedCtor() {
  _cached_size_ = 0;
  load_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MCpuLoad::~MCpuLoad() {
  SharedDtor();
}

void MCpuLoad::SharedDtor() {
  if (this != default_instance_) {
  }
}

void MCpuLoad::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MCpuLoad::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MCpuLoad_descriptor_;
}

const MCpuLoad& MCpuLoad::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CollectDatatMessage_2eproto();
  return *default_instance_;
}

MCpuLoad* MCpuLoad::default_instance_ = NULL;

MCpuLoad* MCpuLoad::New() const {
  return new MCpuLoad;
}

void MCpuLoad::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    load_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MCpuLoad::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 load = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &load_)));
          set_has_load();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MCpuLoad::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 load = 1;
  if (has_load()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->load(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* MCpuLoad::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional int32 load = 1;
  if (has_load()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->load(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int MCpuLoad::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 load = 1;
    if (has_load()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->load());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MCpuLoad::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MCpuLoad* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MCpuLoad*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MCpuLoad::MergeFrom(const MCpuLoad& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_load()) {
      set_load(from.load());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MCpuLoad::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MCpuLoad::CopyFrom(const MCpuLoad& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MCpuLoad::IsInitialized() const {

  return true;
}

void MCpuLoad::Swap(MCpuLoad* other) {
  if (other != this) {
    std::swap(load_, other->load_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MCpuLoad::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MCpuLoad_descriptor_;
  metadata.reflection = MCpuLoad_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MMemInfo::kTotalFieldNumber;
const int MMemInfo::kFreeFieldNumber;
const int MMemInfo::kUsageFieldNumber;
#endif  // !_MSC_VER

MMemInfo::MMemInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void MMemInfo::InitAsDefaultInstance() {
}

MMemInfo::MMemInfo(const MMemInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void MMemInfo::SharedCtor() {
  _cached_size_ = 0;
  total_ = GOOGLE_LONGLONG(0);
  free_ = GOOGLE_LONGLONG(0);
  usage_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MMemInfo::~MMemInfo() {
  SharedDtor();
}

void MMemInfo::SharedDtor() {
  if (this != default_instance_) {
  }
}

void MMemInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MMemInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MMemInfo_descriptor_;
}

const MMemInfo& MMemInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CollectDatatMessage_2eproto();
  return *default_instance_;
}

MMemInfo* MMemInfo::default_instance_ = NULL;

MMemInfo* MMemInfo::New() const {
  return new MMemInfo;
}

void MMemInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    total_ = GOOGLE_LONGLONG(0);
    free_ = GOOGLE_LONGLONG(0);
    usage_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MMemInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int64 total = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &total_)));
          set_has_total();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_free;
        break;
      }

      // optional int64 free = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_free:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &free_)));
          set_has_free();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(29)) goto parse_usage;
        break;
      }

      // optional float usage = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_usage:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &usage_)));
          set_has_usage();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MMemInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int64 total = 1;
  if (has_total()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->total(), output);
  }

  // optional int64 free = 2;
  if (has_free()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(2, this->free(), output);
  }

  // optional float usage = 3;
  if (has_usage()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->usage(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* MMemInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional int64 total = 1;
  if (has_total()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->total(), target);
  }

  // optional int64 free = 2;
  if (has_free()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(2, this->free(), target);
  }

  // optional float usage = 3;
  if (has_usage()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->usage(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int MMemInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int64 total = 1;
    if (has_total()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->total());
    }

    // optional int64 free = 2;
    if (has_free()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->free());
    }

    // optional float usage = 3;
    if (has_usage()) {
      total_size += 1 + 4;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MMemInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MMemInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MMemInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MMemInfo::MergeFrom(const MMemInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_total()) {
      set_total(from.total());
    }
    if (from.has_free()) {
      set_free(from.free());
    }
    if (from.has_usage()) {
      set_usage(from.usage());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MMemInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MMemInfo::CopyFrom(const MMemInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MMemInfo::IsInitialized() const {

  return true;
}

void MMemInfo::Swap(MMemInfo* other) {
  if (other != this) {
    std::swap(total_, other->total_);
    std::swap(free_, other->free_);
    std::swap(usage_, other->usage_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MMemInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MMemInfo_descriptor_;
  metadata.reflection = MMemInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MDiskInfoItem::kSpaceFieldNumber;
const int MDiskInfoItem::kUsedFieldNumber;
const int MDiskInfoItem::kAvailableFieldNumber;
const int MDiskInfoItem::kUsageFieldNumber;
const int MDiskInfoItem::kMountPointFieldNumber;
#endif  // !_MSC_VER

MDiskInfoItem::MDiskInfoItem()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void MDiskInfoItem::InitAsDefaultInstance() {
}

MDiskInfoItem::MDiskInfoItem(const MDiskInfoItem& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void MDiskInfoItem::SharedCtor() {
  _cached_size_ = 0;
  space_ = 0;
  used_ = 0;
  available_ = 0;
  usage_ = 0;
  mount_point_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MDiskInfoItem::~MDiskInfoItem() {
  SharedDtor();
}

void MDiskInfoItem::SharedDtor() {
  if (mount_point_ != &::google::protobuf::internal::kEmptyString) {
    delete mount_point_;
  }
  if (this != default_instance_) {
  }
}

void MDiskInfoItem::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MDiskInfoItem::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MDiskInfoItem_descriptor_;
}

const MDiskInfoItem& MDiskInfoItem::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CollectDatatMessage_2eproto();
  return *default_instance_;
}

MDiskInfoItem* MDiskInfoItem::default_instance_ = NULL;

MDiskInfoItem* MDiskInfoItem::New() const {
  return new MDiskInfoItem;
}

void MDiskInfoItem::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    space_ = 0;
    used_ = 0;
    available_ = 0;
    usage_ = 0;
    if (has_mount_point()) {
      if (mount_point_ != &::google::protobuf::internal::kEmptyString) {
        mount_point_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MDiskInfoItem::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional float space = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &space_)));
          set_has_space();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_used;
        break;
      }

      // optional float used = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_used:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &used_)));
          set_has_used();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(29)) goto parse_available;
        break;
      }

      // optional float available = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_available:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &available_)));
          set_has_available();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(37)) goto parse_usage;
        break;
      }

      // optional float usage = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_usage:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &usage_)));
          set_has_usage();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_mount_point;
        break;
      }

      // optional string mount_point = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_mount_point:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_mount_point()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->mount_point().data(), this->mount_point().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MDiskInfoItem::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional float space = 1;
  if (has_space()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->space(), output);
  }

  // optional float used = 2;
  if (has_used()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->used(), output);
  }

  // optional float available = 3;
  if (has_available()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->available(), output);
  }

  // optional float usage = 4;
  if (has_usage()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->usage(), output);
  }

  // optional string mount_point = 5;
  if (has_mount_point()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->mount_point().data(), this->mount_point().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      5, this->mount_point(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* MDiskInfoItem::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional float space = 1;
  if (has_space()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->space(), target);
  }

  // optional float used = 2;
  if (has_used()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->used(), target);
  }

  // optional float available = 3;
  if (has_available()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->available(), target);
  }

  // optional float usage = 4;
  if (has_usage()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(4, this->usage(), target);
  }

  // optional string mount_point = 5;
  if (has_mount_point()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->mount_point().data(), this->mount_point().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->mount_point(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int MDiskInfoItem::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional float space = 1;
    if (has_space()) {
      total_size += 1 + 4;
    }

    // optional float used = 2;
    if (has_used()) {
      total_size += 1 + 4;
    }

    // optional float available = 3;
    if (has_available()) {
      total_size += 1 + 4;
    }

    // optional float usage = 4;
    if (has_usage()) {
      total_size += 1 + 4;
    }

    // optional string mount_point = 5;
    if (has_mount_point()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->mount_point());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MDiskInfoItem::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MDiskInfoItem* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MDiskInfoItem*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MDiskInfoItem::MergeFrom(const MDiskInfoItem& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_space()) {
      set_space(from.space());
    }
    if (from.has_used()) {
      set_used(from.used());
    }
    if (from.has_available()) {
      set_available(from.available());
    }
    if (from.has_usage()) {
      set_usage(from.usage());
    }
    if (from.has_mount_point()) {
      set_mount_point(from.mount_point());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MDiskInfoItem::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MDiskInfoItem::CopyFrom(const MDiskInfoItem& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MDiskInfoItem::IsInitialized() const {

  return true;
}

void MDiskInfoItem::Swap(MDiskInfoItem* other) {
  if (other != this) {
    std::swap(space_, other->space_);
    std::swap(used_, other->used_);
    std::swap(available_, other->available_);
    std::swap(usage_, other->usage_);
    std::swap(mount_point_, other->mount_point_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MDiskInfoItem::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MDiskInfoItem_descriptor_;
  metadata.reflection = MDiskInfoItem_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MDiskInfo::kDiskinfoFieldNumber;
#endif  // !_MSC_VER

MDiskInfo::MDiskInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void MDiskInfo::InitAsDefaultInstance() {
}

MDiskInfo::MDiskInfo(const MDiskInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void MDiskInfo::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MDiskInfo::~MDiskInfo() {
  SharedDtor();
}

void MDiskInfo::SharedDtor() {
  if (this != default_instance_) {
  }
}

void MDiskInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MDiskInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MDiskInfo_descriptor_;
}

const MDiskInfo& MDiskInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CollectDatatMessage_2eproto();
  return *default_instance_;
}

MDiskInfo* MDiskInfo::default_instance_ = NULL;

MDiskInfo* MDiskInfo::New() const {
  return new MDiskInfo;
}

void MDiskInfo::Clear() {
  diskinfo_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MDiskInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .COLLECT_DATA.MDiskInfoItem diskinfo = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_diskinfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_diskinfo()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_diskinfo;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MDiskInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .COLLECT_DATA.MDiskInfoItem diskinfo = 1;
  for (int i = 0; i < this->diskinfo_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->diskinfo(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* MDiskInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .COLLECT_DATA.MDiskInfoItem diskinfo = 1;
  for (int i = 0; i < this->diskinfo_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->diskinfo(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int MDiskInfo::ByteSize() const {
  int total_size = 0;

  // repeated .COLLECT_DATA.MDiskInfoItem diskinfo = 1;
  total_size += 1 * this->diskinfo_size();
  for (int i = 0; i < this->diskinfo_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->diskinfo(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MDiskInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MDiskInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MDiskInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MDiskInfo::MergeFrom(const MDiskInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  diskinfo_.MergeFrom(from.diskinfo_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MDiskInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MDiskInfo::CopyFrom(const MDiskInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MDiskInfo::IsInitialized() const {

  return true;
}

void MDiskInfo::Swap(MDiskInfo* other) {
  if (other != this) {
    diskinfo_.Swap(&other->diskinfo_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MDiskInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MDiskInfo_descriptor_;
  metadata.reflection = MDiskInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MFangquStatusItem::kStatusFieldNumber;
#endif  // !_MSC_VER

MFangquStatusItem::MFangquStatusItem()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void MFangquStatusItem::InitAsDefaultInstance() {
}

MFangquStatusItem::MFangquStatusItem(const MFangquStatusItem& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void MFangquStatusItem::SharedCtor() {
  _cached_size_ = 0;
  status_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MFangquStatusItem::~MFangquStatusItem() {
  SharedDtor();
}

void MFangquStatusItem::SharedDtor() {
  if (this != default_instance_) {
  }
}

void MFangquStatusItem::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MFangquStatusItem::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MFangquStatusItem_descriptor_;
}

const MFangquStatusItem& MFangquStatusItem::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CollectDatatMessage_2eproto();
  return *default_instance_;
}

MFangquStatusItem* MFangquStatusItem::default_instance_ = NULL;

MFangquStatusItem* MFangquStatusItem::New() const {
  return new MFangquStatusItem;
}

void MFangquStatusItem::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    status_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MFangquStatusItem::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 status = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &status_)));
          set_has_status();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MFangquStatusItem::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 status = 1;
  if (has_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->status(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* MFangquStatusItem::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional int32 status = 1;
  if (has_status()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->status(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int MFangquStatusItem::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 status = 1;
    if (has_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->status());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MFangquStatusItem::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MFangquStatusItem* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MFangquStatusItem*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MFangquStatusItem::MergeFrom(const MFangquStatusItem& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_status()) {
      set_status(from.status());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MFangquStatusItem::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MFangquStatusItem::CopyFrom(const MFangquStatusItem& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MFangquStatusItem::IsInitialized() const {

  return true;
}

void MFangquStatusItem::Swap(MFangquStatusItem* other) {
  if (other != this) {
    std::swap(status_, other->status_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MFangquStatusItem::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MFangquStatusItem_descriptor_;
  metadata.reflection = MFangquStatusItem_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MSKHostInfoItem::kIpFieldNumber;
const int MSKHostInfoItem::kHostStatusFieldNumber;
const int MSKHostInfoItem::kFangquTypeFieldNumber;
const int MSKHostInfoItem::kFangquStatusFieldNumber;
#endif  // !_MSC_VER

MSKHostInfoItem::MSKHostInfoItem()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void MSKHostInfoItem::InitAsDefaultInstance() {
}

MSKHostInfoItem::MSKHostInfoItem(const MSKHostInfoItem& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void MSKHostInfoItem::SharedCtor() {
  _cached_size_ = 0;
  ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  host_status_ = 0;
  fangqu_type_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MSKHostInfoItem::~MSKHostInfoItem() {
  SharedDtor();
}

void MSKHostInfoItem::SharedDtor() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_;
  }
  if (this != default_instance_) {
  }
}

void MSKHostInfoItem::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MSKHostInfoItem::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MSKHostInfoItem_descriptor_;
}

const MSKHostInfoItem& MSKHostInfoItem::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CollectDatatMessage_2eproto();
  return *default_instance_;
}

MSKHostInfoItem* MSKHostInfoItem::default_instance_ = NULL;

MSKHostInfoItem* MSKHostInfoItem::New() const {
  return new MSKHostInfoItem;
}

void MSKHostInfoItem::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_ip()) {
      if (ip_ != &::google::protobuf::internal::kEmptyString) {
        ip_->clear();
      }
    }
    host_status_ = 0;
    fangqu_type_ = 0;
  }
  fangqu_status_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MSKHostInfoItem::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string ip = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_ip()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->ip().data(), this->ip().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_host_status;
        break;
      }

      // optional int32 host_status = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_host_status:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &host_status_)));
          set_has_host_status();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_fangqu_type;
        break;
      }

      // optional int32 fangqu_type = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_fangqu_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &fangqu_type_)));
          set_has_fangqu_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_fangqu_status;
        break;
      }

      // repeated .COLLECT_DATA.MFangquStatusItem fangqu_status = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_fangqu_status:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_fangqu_status()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_fangqu_status;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MSKHostInfoItem::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string ip = 1;
  if (has_ip()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->ip().data(), this->ip().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->ip(), output);
  }

  // optional int32 host_status = 2;
  if (has_host_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->host_status(), output);
  }

  // optional int32 fangqu_type = 3;
  if (has_fangqu_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->fangqu_type(), output);
  }

  // repeated .COLLECT_DATA.MFangquStatusItem fangqu_status = 4;
  for (int i = 0; i < this->fangqu_status_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->fangqu_status(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* MSKHostInfoItem::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string ip = 1;
  if (has_ip()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->ip().data(), this->ip().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->ip(), target);
  }

  // optional int32 host_status = 2;
  if (has_host_status()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->host_status(), target);
  }

  // optional int32 fangqu_type = 3;
  if (has_fangqu_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->fangqu_type(), target);
  }

  // repeated .COLLECT_DATA.MFangquStatusItem fangqu_status = 4;
  for (int i = 0; i < this->fangqu_status_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->fangqu_status(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int MSKHostInfoItem::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string ip = 1;
    if (has_ip()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->ip());
    }

    // optional int32 host_status = 2;
    if (has_host_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->host_status());
    }

    // optional int32 fangqu_type = 3;
    if (has_fangqu_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->fangqu_type());
    }

  }
  // repeated .COLLECT_DATA.MFangquStatusItem fangqu_status = 4;
  total_size += 1 * this->fangqu_status_size();
  for (int i = 0; i < this->fangqu_status_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->fangqu_status(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MSKHostInfoItem::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MSKHostInfoItem* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MSKHostInfoItem*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MSKHostInfoItem::MergeFrom(const MSKHostInfoItem& from) {
  GOOGLE_CHECK_NE(&from, this);
  fangqu_status_.MergeFrom(from.fangqu_status_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ip()) {
      set_ip(from.ip());
    }
    if (from.has_host_status()) {
      set_host_status(from.host_status());
    }
    if (from.has_fangqu_type()) {
      set_fangqu_type(from.fangqu_type());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MSKHostInfoItem::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MSKHostInfoItem::CopyFrom(const MSKHostInfoItem& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MSKHostInfoItem::IsInitialized() const {

  return true;
}

void MSKHostInfoItem::Swap(MSKHostInfoItem* other) {
  if (other != this) {
    std::swap(ip_, other->ip_);
    std::swap(host_status_, other->host_status_);
    std::swap(fangqu_type_, other->fangqu_type_);
    fangqu_status_.Swap(&other->fangqu_status_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MSKHostInfoItem::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MSKHostInfoItem_descriptor_;
  metadata.reflection = MSKHostInfoItem_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MSKHostInfos::kSkAlarmFieldNumber;
#endif  // !_MSC_VER

MSKHostInfos::MSKHostInfos()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void MSKHostInfos::InitAsDefaultInstance() {
}

MSKHostInfos::MSKHostInfos(const MSKHostInfos& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void MSKHostInfos::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MSKHostInfos::~MSKHostInfos() {
  SharedDtor();
}

void MSKHostInfos::SharedDtor() {
  if (this != default_instance_) {
  }
}

void MSKHostInfos::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MSKHostInfos::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MSKHostInfos_descriptor_;
}

const MSKHostInfos& MSKHostInfos::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CollectDatatMessage_2eproto();
  return *default_instance_;
}

MSKHostInfos* MSKHostInfos::default_instance_ = NULL;

MSKHostInfos* MSKHostInfos::New() const {
  return new MSKHostInfos;
}

void MSKHostInfos::Clear() {
  sk_alarm_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MSKHostInfos::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .COLLECT_DATA.MSKHostInfoItem sk_alarm = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_sk_alarm:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_sk_alarm()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_sk_alarm;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MSKHostInfos::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .COLLECT_DATA.MSKHostInfoItem sk_alarm = 1;
  for (int i = 0; i < this->sk_alarm_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->sk_alarm(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* MSKHostInfos::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .COLLECT_DATA.MSKHostInfoItem sk_alarm = 1;
  for (int i = 0; i < this->sk_alarm_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->sk_alarm(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int MSKHostInfos::ByteSize() const {
  int total_size = 0;

  // repeated .COLLECT_DATA.MSKHostInfoItem sk_alarm = 1;
  total_size += 1 * this->sk_alarm_size();
  for (int i = 0; i < this->sk_alarm_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->sk_alarm(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MSKHostInfos::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MSKHostInfos* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MSKHostInfos*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MSKHostInfos::MergeFrom(const MSKHostInfos& from) {
  GOOGLE_CHECK_NE(&from, this);
  sk_alarm_.MergeFrom(from.sk_alarm_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MSKHostInfos::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MSKHostInfos::CopyFrom(const MSKHostInfos& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MSKHostInfos::IsInitialized() const {

  return true;
}

void MSKHostInfos::Swap(MSKHostInfos* other) {
  if (other != this) {
    sk_alarm_.Swap(&other->sk_alarm_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MSKHostInfos::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MSKHostInfos_descriptor_;
  metadata.reflection = MSKHostInfos_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace COLLECT_DATA

// @@protoc_insertion_point(global_scope)
