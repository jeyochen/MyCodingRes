// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: CollectDatatMessage.proto

#ifndef PROTOBUF_CollectDatatMessage_2eproto__INCLUDED
#define PROTOBUF_CollectDatatMessage_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace COLLECT_DATA {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_CollectDatatMessage_2eproto();
void protobuf_AssignDesc_CollectDatatMessage_2eproto();
void protobuf_ShutdownFile_CollectDatatMessage_2eproto();

class MSixLineDC;
class MSixLineStatus;
class MTemperHumidityValue;
class MCpuLoad;
class MMemInfo;
class MDiskInfoItem;
class MDiskInfo;
class MFangquStatusItem;
class MSKHostInfoItem;
class MSKHostInfos;

// ===================================================================

class MSixLineDC : public ::google::protobuf::Message {
 public:
  MSixLineDC();
  virtual ~MSixLineDC();

  MSixLineDC(const MSixLineDC& from);

  inline MSixLineDC& operator=(const MSixLineDC& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MSixLineDC& default_instance();

  void Swap(MSixLineDC* other);

  // implements Message ----------------------------------------------

  MSixLineDC* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MSixLineDC& from);
  void MergeFrom(const MSixLineDC& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float line_dc = 1;
  inline int line_dc_size() const;
  inline void clear_line_dc();
  static const int kLineDcFieldNumber = 1;
  inline float line_dc(int index) const;
  inline void set_line_dc(int index, float value);
  inline void add_line_dc(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      line_dc() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_line_dc();

  // @@protoc_insertion_point(class_scope:COLLECT_DATA.MSixLineDC)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< float > line_dc_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_CollectDatatMessage_2eproto();
  friend void protobuf_AssignDesc_CollectDatatMessage_2eproto();
  friend void protobuf_ShutdownFile_CollectDatatMessage_2eproto();

  void InitAsDefaultInstance();
  static MSixLineDC* default_instance_;
};
// -------------------------------------------------------------------

class MSixLineStatus : public ::google::protobuf::Message {
 public:
  MSixLineStatus();
  virtual ~MSixLineStatus();

  MSixLineStatus(const MSixLineStatus& from);

  inline MSixLineStatus& operator=(const MSixLineStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MSixLineStatus& default_instance();

  void Swap(MSixLineStatus* other);

  // implements Message ----------------------------------------------

  MSixLineStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MSixLineStatus& from);
  void MergeFrom(const MSixLineStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bool line_status = 1;
  inline int line_status_size() const;
  inline void clear_line_status();
  static const int kLineStatusFieldNumber = 1;
  inline bool line_status(int index) const;
  inline void set_line_status(int index, bool value);
  inline void add_line_status(bool value);
  inline const ::google::protobuf::RepeatedField< bool >&
      line_status() const;
  inline ::google::protobuf::RepeatedField< bool >*
      mutable_line_status();

  // @@protoc_insertion_point(class_scope:COLLECT_DATA.MSixLineStatus)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< bool > line_status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_CollectDatatMessage_2eproto();
  friend void protobuf_AssignDesc_CollectDatatMessage_2eproto();
  friend void protobuf_ShutdownFile_CollectDatatMessage_2eproto();

  void InitAsDefaultInstance();
  static MSixLineStatus* default_instance_;
};
// -------------------------------------------------------------------

class MTemperHumidityValue : public ::google::protobuf::Message {
 public:
  MTemperHumidityValue();
  virtual ~MTemperHumidityValue();

  MTemperHumidityValue(const MTemperHumidityValue& from);

  inline MTemperHumidityValue& operator=(const MTemperHumidityValue& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MTemperHumidityValue& default_instance();

  void Swap(MTemperHumidityValue* other);

  // implements Message ----------------------------------------------

  MTemperHumidityValue* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MTemperHumidityValue& from);
  void MergeFrom(const MTemperHumidityValue& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float temperature = 1;
  inline bool has_temperature() const;
  inline void clear_temperature();
  static const int kTemperatureFieldNumber = 1;
  inline float temperature() const;
  inline void set_temperature(float value);

  // optional float humidity = 2;
  inline bool has_humidity() const;
  inline void clear_humidity();
  static const int kHumidityFieldNumber = 2;
  inline float humidity() const;
  inline void set_humidity(float value);

  // @@protoc_insertion_point(class_scope:COLLECT_DATA.MTemperHumidityValue)
 private:
  inline void set_has_temperature();
  inline void clear_has_temperature();
  inline void set_has_humidity();
  inline void clear_has_humidity();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float temperature_;
  float humidity_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CollectDatatMessage_2eproto();
  friend void protobuf_AssignDesc_CollectDatatMessage_2eproto();
  friend void protobuf_ShutdownFile_CollectDatatMessage_2eproto();

  void InitAsDefaultInstance();
  static MTemperHumidityValue* default_instance_;
};
// -------------------------------------------------------------------

class MCpuLoad : public ::google::protobuf::Message {
 public:
  MCpuLoad();
  virtual ~MCpuLoad();

  MCpuLoad(const MCpuLoad& from);

  inline MCpuLoad& operator=(const MCpuLoad& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MCpuLoad& default_instance();

  void Swap(MCpuLoad* other);

  // implements Message ----------------------------------------------

  MCpuLoad* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MCpuLoad& from);
  void MergeFrom(const MCpuLoad& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 load = 1;
  inline bool has_load() const;
  inline void clear_load();
  static const int kLoadFieldNumber = 1;
  inline ::google::protobuf::int32 load() const;
  inline void set_load(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:COLLECT_DATA.MCpuLoad)
 private:
  inline void set_has_load();
  inline void clear_has_load();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 load_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_CollectDatatMessage_2eproto();
  friend void protobuf_AssignDesc_CollectDatatMessage_2eproto();
  friend void protobuf_ShutdownFile_CollectDatatMessage_2eproto();

  void InitAsDefaultInstance();
  static MCpuLoad* default_instance_;
};
// -------------------------------------------------------------------

class MMemInfo : public ::google::protobuf::Message {
 public:
  MMemInfo();
  virtual ~MMemInfo();

  MMemInfo(const MMemInfo& from);

  inline MMemInfo& operator=(const MMemInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MMemInfo& default_instance();

  void Swap(MMemInfo* other);

  // implements Message ----------------------------------------------

  MMemInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MMemInfo& from);
  void MergeFrom(const MMemInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 total = 1;
  inline bool has_total() const;
  inline void clear_total();
  static const int kTotalFieldNumber = 1;
  inline ::google::protobuf::int64 total() const;
  inline void set_total(::google::protobuf::int64 value);

  // optional int64 free = 2;
  inline bool has_free() const;
  inline void clear_free();
  static const int kFreeFieldNumber = 2;
  inline ::google::protobuf::int64 free() const;
  inline void set_free(::google::protobuf::int64 value);

  // optional float usage = 3;
  inline bool has_usage() const;
  inline void clear_usage();
  static const int kUsageFieldNumber = 3;
  inline float usage() const;
  inline void set_usage(float value);

  // @@protoc_insertion_point(class_scope:COLLECT_DATA.MMemInfo)
 private:
  inline void set_has_total();
  inline void clear_has_total();
  inline void set_has_free();
  inline void clear_has_free();
  inline void set_has_usage();
  inline void clear_has_usage();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 total_;
  ::google::protobuf::int64 free_;
  float usage_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_CollectDatatMessage_2eproto();
  friend void protobuf_AssignDesc_CollectDatatMessage_2eproto();
  friend void protobuf_ShutdownFile_CollectDatatMessage_2eproto();

  void InitAsDefaultInstance();
  static MMemInfo* default_instance_;
};
// -------------------------------------------------------------------

class MDiskInfoItem : public ::google::protobuf::Message {
 public:
  MDiskInfoItem();
  virtual ~MDiskInfoItem();

  MDiskInfoItem(const MDiskInfoItem& from);

  inline MDiskInfoItem& operator=(const MDiskInfoItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MDiskInfoItem& default_instance();

  void Swap(MDiskInfoItem* other);

  // implements Message ----------------------------------------------

  MDiskInfoItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MDiskInfoItem& from);
  void MergeFrom(const MDiskInfoItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float space = 1;
  inline bool has_space() const;
  inline void clear_space();
  static const int kSpaceFieldNumber = 1;
  inline float space() const;
  inline void set_space(float value);

  // optional float used = 2;
  inline bool has_used() const;
  inline void clear_used();
  static const int kUsedFieldNumber = 2;
  inline float used() const;
  inline void set_used(float value);

  // optional float available = 3;
  inline bool has_available() const;
  inline void clear_available();
  static const int kAvailableFieldNumber = 3;
  inline float available() const;
  inline void set_available(float value);

  // optional float usage = 4;
  inline bool has_usage() const;
  inline void clear_usage();
  static const int kUsageFieldNumber = 4;
  inline float usage() const;
  inline void set_usage(float value);

  // optional string mount_point = 5;
  inline bool has_mount_point() const;
  inline void clear_mount_point();
  static const int kMountPointFieldNumber = 5;
  inline const ::std::string& mount_point() const;
  inline void set_mount_point(const ::std::string& value);
  inline void set_mount_point(const char* value);
  inline void set_mount_point(const char* value, size_t size);
  inline ::std::string* mutable_mount_point();
  inline ::std::string* release_mount_point();
  inline void set_allocated_mount_point(::std::string* mount_point);

  // @@protoc_insertion_point(class_scope:COLLECT_DATA.MDiskInfoItem)
 private:
  inline void set_has_space();
  inline void clear_has_space();
  inline void set_has_used();
  inline void clear_has_used();
  inline void set_has_available();
  inline void clear_has_available();
  inline void set_has_usage();
  inline void clear_has_usage();
  inline void set_has_mount_point();
  inline void clear_has_mount_point();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float space_;
  float used_;
  float available_;
  float usage_;
  ::std::string* mount_point_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_CollectDatatMessage_2eproto();
  friend void protobuf_AssignDesc_CollectDatatMessage_2eproto();
  friend void protobuf_ShutdownFile_CollectDatatMessage_2eproto();

  void InitAsDefaultInstance();
  static MDiskInfoItem* default_instance_;
};
// -------------------------------------------------------------------

class MDiskInfo : public ::google::protobuf::Message {
 public:
  MDiskInfo();
  virtual ~MDiskInfo();

  MDiskInfo(const MDiskInfo& from);

  inline MDiskInfo& operator=(const MDiskInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MDiskInfo& default_instance();

  void Swap(MDiskInfo* other);

  // implements Message ----------------------------------------------

  MDiskInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MDiskInfo& from);
  void MergeFrom(const MDiskInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .COLLECT_DATA.MDiskInfoItem diskinfo = 1;
  inline int diskinfo_size() const;
  inline void clear_diskinfo();
  static const int kDiskinfoFieldNumber = 1;
  inline const ::COLLECT_DATA::MDiskInfoItem& diskinfo(int index) const;
  inline ::COLLECT_DATA::MDiskInfoItem* mutable_diskinfo(int index);
  inline ::COLLECT_DATA::MDiskInfoItem* add_diskinfo();
  inline const ::google::protobuf::RepeatedPtrField< ::COLLECT_DATA::MDiskInfoItem >&
      diskinfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::COLLECT_DATA::MDiskInfoItem >*
      mutable_diskinfo();

  // @@protoc_insertion_point(class_scope:COLLECT_DATA.MDiskInfo)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::COLLECT_DATA::MDiskInfoItem > diskinfo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_CollectDatatMessage_2eproto();
  friend void protobuf_AssignDesc_CollectDatatMessage_2eproto();
  friend void protobuf_ShutdownFile_CollectDatatMessage_2eproto();

  void InitAsDefaultInstance();
  static MDiskInfo* default_instance_;
};
// -------------------------------------------------------------------

class MFangquStatusItem : public ::google::protobuf::Message {
 public:
  MFangquStatusItem();
  virtual ~MFangquStatusItem();

  MFangquStatusItem(const MFangquStatusItem& from);

  inline MFangquStatusItem& operator=(const MFangquStatusItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MFangquStatusItem& default_instance();

  void Swap(MFangquStatusItem* other);

  // implements Message ----------------------------------------------

  MFangquStatusItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MFangquStatusItem& from);
  void MergeFrom(const MFangquStatusItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:COLLECT_DATA.MFangquStatusItem)
 private:
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_CollectDatatMessage_2eproto();
  friend void protobuf_AssignDesc_CollectDatatMessage_2eproto();
  friend void protobuf_ShutdownFile_CollectDatatMessage_2eproto();

  void InitAsDefaultInstance();
  static MFangquStatusItem* default_instance_;
};
// -------------------------------------------------------------------

class MSKHostInfoItem : public ::google::protobuf::Message {
 public:
  MSKHostInfoItem();
  virtual ~MSKHostInfoItem();

  MSKHostInfoItem(const MSKHostInfoItem& from);

  inline MSKHostInfoItem& operator=(const MSKHostInfoItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MSKHostInfoItem& default_instance();

  void Swap(MSKHostInfoItem* other);

  // implements Message ----------------------------------------------

  MSKHostInfoItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MSKHostInfoItem& from);
  void MergeFrom(const MSKHostInfoItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string ip = 1;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 1;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // optional int32 host_status = 2;
  inline bool has_host_status() const;
  inline void clear_host_status();
  static const int kHostStatusFieldNumber = 2;
  inline ::google::protobuf::int32 host_status() const;
  inline void set_host_status(::google::protobuf::int32 value);

  // optional int32 fangqu_type = 3;
  inline bool has_fangqu_type() const;
  inline void clear_fangqu_type();
  static const int kFangquTypeFieldNumber = 3;
  inline ::google::protobuf::int32 fangqu_type() const;
  inline void set_fangqu_type(::google::protobuf::int32 value);

  // repeated .COLLECT_DATA.MFangquStatusItem fangqu_status = 4;
  inline int fangqu_status_size() const;
  inline void clear_fangqu_status();
  static const int kFangquStatusFieldNumber = 4;
  inline const ::COLLECT_DATA::MFangquStatusItem& fangqu_status(int index) const;
  inline ::COLLECT_DATA::MFangquStatusItem* mutable_fangqu_status(int index);
  inline ::COLLECT_DATA::MFangquStatusItem* add_fangqu_status();
  inline const ::google::protobuf::RepeatedPtrField< ::COLLECT_DATA::MFangquStatusItem >&
      fangqu_status() const;
  inline ::google::protobuf::RepeatedPtrField< ::COLLECT_DATA::MFangquStatusItem >*
      mutable_fangqu_status();

  // @@protoc_insertion_point(class_scope:COLLECT_DATA.MSKHostInfoItem)
 private:
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_host_status();
  inline void clear_has_host_status();
  inline void set_has_fangqu_type();
  inline void clear_has_fangqu_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* ip_;
  ::google::protobuf::int32 host_status_;
  ::google::protobuf::int32 fangqu_type_;
  ::google::protobuf::RepeatedPtrField< ::COLLECT_DATA::MFangquStatusItem > fangqu_status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_CollectDatatMessage_2eproto();
  friend void protobuf_AssignDesc_CollectDatatMessage_2eproto();
  friend void protobuf_ShutdownFile_CollectDatatMessage_2eproto();

  void InitAsDefaultInstance();
  static MSKHostInfoItem* default_instance_;
};
// -------------------------------------------------------------------

class MSKHostInfos : public ::google::protobuf::Message {
 public:
  MSKHostInfos();
  virtual ~MSKHostInfos();

  MSKHostInfos(const MSKHostInfos& from);

  inline MSKHostInfos& operator=(const MSKHostInfos& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MSKHostInfos& default_instance();

  void Swap(MSKHostInfos* other);

  // implements Message ----------------------------------------------

  MSKHostInfos* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MSKHostInfos& from);
  void MergeFrom(const MSKHostInfos& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .COLLECT_DATA.MSKHostInfoItem sk_alarm = 1;
  inline int sk_alarm_size() const;
  inline void clear_sk_alarm();
  static const int kSkAlarmFieldNumber = 1;
  inline const ::COLLECT_DATA::MSKHostInfoItem& sk_alarm(int index) const;
  inline ::COLLECT_DATA::MSKHostInfoItem* mutable_sk_alarm(int index);
  inline ::COLLECT_DATA::MSKHostInfoItem* add_sk_alarm();
  inline const ::google::protobuf::RepeatedPtrField< ::COLLECT_DATA::MSKHostInfoItem >&
      sk_alarm() const;
  inline ::google::protobuf::RepeatedPtrField< ::COLLECT_DATA::MSKHostInfoItem >*
      mutable_sk_alarm();

  // @@protoc_insertion_point(class_scope:COLLECT_DATA.MSKHostInfos)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::COLLECT_DATA::MSKHostInfoItem > sk_alarm_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_CollectDatatMessage_2eproto();
  friend void protobuf_AssignDesc_CollectDatatMessage_2eproto();
  friend void protobuf_ShutdownFile_CollectDatatMessage_2eproto();

  void InitAsDefaultInstance();
  static MSKHostInfos* default_instance_;
};
// ===================================================================


// ===================================================================

// MSixLineDC

// repeated float line_dc = 1;
inline int MSixLineDC::line_dc_size() const {
  return line_dc_.size();
}
inline void MSixLineDC::clear_line_dc() {
  line_dc_.Clear();
}
inline float MSixLineDC::line_dc(int index) const {
  return line_dc_.Get(index);
}
inline void MSixLineDC::set_line_dc(int index, float value) {
  line_dc_.Set(index, value);
}
inline void MSixLineDC::add_line_dc(float value) {
  line_dc_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
MSixLineDC::line_dc() const {
  return line_dc_;
}
inline ::google::protobuf::RepeatedField< float >*
MSixLineDC::mutable_line_dc() {
  return &line_dc_;
}

// -------------------------------------------------------------------

// MSixLineStatus

// repeated bool line_status = 1;
inline int MSixLineStatus::line_status_size() const {
  return line_status_.size();
}
inline void MSixLineStatus::clear_line_status() {
  line_status_.Clear();
}
inline bool MSixLineStatus::line_status(int index) const {
  return line_status_.Get(index);
}
inline void MSixLineStatus::set_line_status(int index, bool value) {
  line_status_.Set(index, value);
}
inline void MSixLineStatus::add_line_status(bool value) {
  line_status_.Add(value);
}
inline const ::google::protobuf::RepeatedField< bool >&
MSixLineStatus::line_status() const {
  return line_status_;
}
inline ::google::protobuf::RepeatedField< bool >*
MSixLineStatus::mutable_line_status() {
  return &line_status_;
}

// -------------------------------------------------------------------

// MTemperHumidityValue

// optional float temperature = 1;
inline bool MTemperHumidityValue::has_temperature() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MTemperHumidityValue::set_has_temperature() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MTemperHumidityValue::clear_has_temperature() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MTemperHumidityValue::clear_temperature() {
  temperature_ = 0;
  clear_has_temperature();
}
inline float MTemperHumidityValue::temperature() const {
  return temperature_;
}
inline void MTemperHumidityValue::set_temperature(float value) {
  set_has_temperature();
  temperature_ = value;
}

// optional float humidity = 2;
inline bool MTemperHumidityValue::has_humidity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MTemperHumidityValue::set_has_humidity() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MTemperHumidityValue::clear_has_humidity() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MTemperHumidityValue::clear_humidity() {
  humidity_ = 0;
  clear_has_humidity();
}
inline float MTemperHumidityValue::humidity() const {
  return humidity_;
}
inline void MTemperHumidityValue::set_humidity(float value) {
  set_has_humidity();
  humidity_ = value;
}

// -------------------------------------------------------------------

// MCpuLoad

// optional int32 load = 1;
inline bool MCpuLoad::has_load() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MCpuLoad::set_has_load() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MCpuLoad::clear_has_load() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MCpuLoad::clear_load() {
  load_ = 0;
  clear_has_load();
}
inline ::google::protobuf::int32 MCpuLoad::load() const {
  return load_;
}
inline void MCpuLoad::set_load(::google::protobuf::int32 value) {
  set_has_load();
  load_ = value;
}

// -------------------------------------------------------------------

// MMemInfo

// optional int64 total = 1;
inline bool MMemInfo::has_total() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MMemInfo::set_has_total() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MMemInfo::clear_has_total() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MMemInfo::clear_total() {
  total_ = GOOGLE_LONGLONG(0);
  clear_has_total();
}
inline ::google::protobuf::int64 MMemInfo::total() const {
  return total_;
}
inline void MMemInfo::set_total(::google::protobuf::int64 value) {
  set_has_total();
  total_ = value;
}

// optional int64 free = 2;
inline bool MMemInfo::has_free() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MMemInfo::set_has_free() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MMemInfo::clear_has_free() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MMemInfo::clear_free() {
  free_ = GOOGLE_LONGLONG(0);
  clear_has_free();
}
inline ::google::protobuf::int64 MMemInfo::free() const {
  return free_;
}
inline void MMemInfo::set_free(::google::protobuf::int64 value) {
  set_has_free();
  free_ = value;
}

// optional float usage = 3;
inline bool MMemInfo::has_usage() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MMemInfo::set_has_usage() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MMemInfo::clear_has_usage() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MMemInfo::clear_usage() {
  usage_ = 0;
  clear_has_usage();
}
inline float MMemInfo::usage() const {
  return usage_;
}
inline void MMemInfo::set_usage(float value) {
  set_has_usage();
  usage_ = value;
}

// -------------------------------------------------------------------

// MDiskInfoItem

// optional float space = 1;
inline bool MDiskInfoItem::has_space() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MDiskInfoItem::set_has_space() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MDiskInfoItem::clear_has_space() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MDiskInfoItem::clear_space() {
  space_ = 0;
  clear_has_space();
}
inline float MDiskInfoItem::space() const {
  return space_;
}
inline void MDiskInfoItem::set_space(float value) {
  set_has_space();
  space_ = value;
}

// optional float used = 2;
inline bool MDiskInfoItem::has_used() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MDiskInfoItem::set_has_used() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MDiskInfoItem::clear_has_used() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MDiskInfoItem::clear_used() {
  used_ = 0;
  clear_has_used();
}
inline float MDiskInfoItem::used() const {
  return used_;
}
inline void MDiskInfoItem::set_used(float value) {
  set_has_used();
  used_ = value;
}

// optional float available = 3;
inline bool MDiskInfoItem::has_available() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MDiskInfoItem::set_has_available() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MDiskInfoItem::clear_has_available() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MDiskInfoItem::clear_available() {
  available_ = 0;
  clear_has_available();
}
inline float MDiskInfoItem::available() const {
  return available_;
}
inline void MDiskInfoItem::set_available(float value) {
  set_has_available();
  available_ = value;
}

// optional float usage = 4;
inline bool MDiskInfoItem::has_usage() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MDiskInfoItem::set_has_usage() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MDiskInfoItem::clear_has_usage() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MDiskInfoItem::clear_usage() {
  usage_ = 0;
  clear_has_usage();
}
inline float MDiskInfoItem::usage() const {
  return usage_;
}
inline void MDiskInfoItem::set_usage(float value) {
  set_has_usage();
  usage_ = value;
}

// optional string mount_point = 5;
inline bool MDiskInfoItem::has_mount_point() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MDiskInfoItem::set_has_mount_point() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MDiskInfoItem::clear_has_mount_point() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MDiskInfoItem::clear_mount_point() {
  if (mount_point_ != &::google::protobuf::internal::kEmptyString) {
    mount_point_->clear();
  }
  clear_has_mount_point();
}
inline const ::std::string& MDiskInfoItem::mount_point() const {
  return *mount_point_;
}
inline void MDiskInfoItem::set_mount_point(const ::std::string& value) {
  set_has_mount_point();
  if (mount_point_ == &::google::protobuf::internal::kEmptyString) {
    mount_point_ = new ::std::string;
  }
  mount_point_->assign(value);
}
inline void MDiskInfoItem::set_mount_point(const char* value) {
  set_has_mount_point();
  if (mount_point_ == &::google::protobuf::internal::kEmptyString) {
    mount_point_ = new ::std::string;
  }
  mount_point_->assign(value);
}
inline void MDiskInfoItem::set_mount_point(const char* value, size_t size) {
  set_has_mount_point();
  if (mount_point_ == &::google::protobuf::internal::kEmptyString) {
    mount_point_ = new ::std::string;
  }
  mount_point_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MDiskInfoItem::mutable_mount_point() {
  set_has_mount_point();
  if (mount_point_ == &::google::protobuf::internal::kEmptyString) {
    mount_point_ = new ::std::string;
  }
  return mount_point_;
}
inline ::std::string* MDiskInfoItem::release_mount_point() {
  clear_has_mount_point();
  if (mount_point_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mount_point_;
    mount_point_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MDiskInfoItem::set_allocated_mount_point(::std::string* mount_point) {
  if (mount_point_ != &::google::protobuf::internal::kEmptyString) {
    delete mount_point_;
  }
  if (mount_point) {
    set_has_mount_point();
    mount_point_ = mount_point;
  } else {
    clear_has_mount_point();
    mount_point_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// MDiskInfo

// repeated .COLLECT_DATA.MDiskInfoItem diskinfo = 1;
inline int MDiskInfo::diskinfo_size() const {
  return diskinfo_.size();
}
inline void MDiskInfo::clear_diskinfo() {
  diskinfo_.Clear();
}
inline const ::COLLECT_DATA::MDiskInfoItem& MDiskInfo::diskinfo(int index) const {
  return diskinfo_.Get(index);
}
inline ::COLLECT_DATA::MDiskInfoItem* MDiskInfo::mutable_diskinfo(int index) {
  return diskinfo_.Mutable(index);
}
inline ::COLLECT_DATA::MDiskInfoItem* MDiskInfo::add_diskinfo() {
  return diskinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::COLLECT_DATA::MDiskInfoItem >&
MDiskInfo::diskinfo() const {
  return diskinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::COLLECT_DATA::MDiskInfoItem >*
MDiskInfo::mutable_diskinfo() {
  return &diskinfo_;
}

// -------------------------------------------------------------------

// MFangquStatusItem

// optional int32 status = 1;
inline bool MFangquStatusItem::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MFangquStatusItem::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MFangquStatusItem::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MFangquStatusItem::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 MFangquStatusItem::status() const {
  return status_;
}
inline void MFangquStatusItem::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// MSKHostInfoItem

// optional string ip = 1;
inline bool MSKHostInfoItem::has_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MSKHostInfoItem::set_has_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MSKHostInfoItem::clear_has_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MSKHostInfoItem::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& MSKHostInfoItem::ip() const {
  return *ip_;
}
inline void MSKHostInfoItem::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void MSKHostInfoItem::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void MSKHostInfoItem::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MSKHostInfoItem::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* MSKHostInfoItem::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MSKHostInfoItem::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 host_status = 2;
inline bool MSKHostInfoItem::has_host_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MSKHostInfoItem::set_has_host_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MSKHostInfoItem::clear_has_host_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MSKHostInfoItem::clear_host_status() {
  host_status_ = 0;
  clear_has_host_status();
}
inline ::google::protobuf::int32 MSKHostInfoItem::host_status() const {
  return host_status_;
}
inline void MSKHostInfoItem::set_host_status(::google::protobuf::int32 value) {
  set_has_host_status();
  host_status_ = value;
}

// optional int32 fangqu_type = 3;
inline bool MSKHostInfoItem::has_fangqu_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MSKHostInfoItem::set_has_fangqu_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MSKHostInfoItem::clear_has_fangqu_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MSKHostInfoItem::clear_fangqu_type() {
  fangqu_type_ = 0;
  clear_has_fangqu_type();
}
inline ::google::protobuf::int32 MSKHostInfoItem::fangqu_type() const {
  return fangqu_type_;
}
inline void MSKHostInfoItem::set_fangqu_type(::google::protobuf::int32 value) {
  set_has_fangqu_type();
  fangqu_type_ = value;
}

// repeated .COLLECT_DATA.MFangquStatusItem fangqu_status = 4;
inline int MSKHostInfoItem::fangqu_status_size() const {
  return fangqu_status_.size();
}
inline void MSKHostInfoItem::clear_fangqu_status() {
  fangqu_status_.Clear();
}
inline const ::COLLECT_DATA::MFangquStatusItem& MSKHostInfoItem::fangqu_status(int index) const {
  return fangqu_status_.Get(index);
}
inline ::COLLECT_DATA::MFangquStatusItem* MSKHostInfoItem::mutable_fangqu_status(int index) {
  return fangqu_status_.Mutable(index);
}
inline ::COLLECT_DATA::MFangquStatusItem* MSKHostInfoItem::add_fangqu_status() {
  return fangqu_status_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::COLLECT_DATA::MFangquStatusItem >&
MSKHostInfoItem::fangqu_status() const {
  return fangqu_status_;
}
inline ::google::protobuf::RepeatedPtrField< ::COLLECT_DATA::MFangquStatusItem >*
MSKHostInfoItem::mutable_fangqu_status() {
  return &fangqu_status_;
}

// -------------------------------------------------------------------

// MSKHostInfos

// repeated .COLLECT_DATA.MSKHostInfoItem sk_alarm = 1;
inline int MSKHostInfos::sk_alarm_size() const {
  return sk_alarm_.size();
}
inline void MSKHostInfos::clear_sk_alarm() {
  sk_alarm_.Clear();
}
inline const ::COLLECT_DATA::MSKHostInfoItem& MSKHostInfos::sk_alarm(int index) const {
  return sk_alarm_.Get(index);
}
inline ::COLLECT_DATA::MSKHostInfoItem* MSKHostInfos::mutable_sk_alarm(int index) {
  return sk_alarm_.Mutable(index);
}
inline ::COLLECT_DATA::MSKHostInfoItem* MSKHostInfos::add_sk_alarm() {
  return sk_alarm_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::COLLECT_DATA::MSKHostInfoItem >&
MSKHostInfos::sk_alarm() const {
  return sk_alarm_;
}
inline ::google::protobuf::RepeatedPtrField< ::COLLECT_DATA::MSKHostInfoItem >*
MSKHostInfos::mutable_sk_alarm() {
  return &sk_alarm_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace COLLECT_DATA

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_CollectDatatMessage_2eproto__INCLUDED
